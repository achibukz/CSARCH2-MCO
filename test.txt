<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cache Simulation System - 4-Way BSA + MRU</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header p {
            color: #7f8c8d;
            font-size: 1.1em;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
        }

        .control-group h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #495057;
            font-weight: 500;
        }

        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: transform 0.2s ease;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #6c757d, #495057);
        }

        .btn-success {
            background: linear-gradient(45deg, #28a745, #20c997);
        }

        .btn-warning {
            background: linear-gradient(45deg, #ffc107, #fd7e14);
        }

        .simulation-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .cache-display {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
        }

        .cache-display h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }

        .cache-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }

        .cache-table th,
        .cache-table td {
            padding: 10px;
            text-align: center;
            border: 2px solid #dee2e6;
        }

        .cache-table th {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            font-weight: 600;
        }

        .cache-table td {
            background: white;
            min-height: 40px;
        }

        .cache-block {
            background: #e3f2fd;
            padding: 5px 10px;
            margin: 2px;
            border-radius: 5px;
            display: inline-block;
            border: 1px solid #2196f3;
            font-weight: 500;
        }

        .mru-order {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .stats-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-item {
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #e9ecef;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            color: #6c757d;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .log-panel {
            margin-top: 30px;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
        }

        .log-content {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        .step-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }

        .current-step {
            background: #fff3cd;
            border: 2px solid #ffeaa7;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            margin: 10px 0;
            font-weight: 500;
        }

        .sequence-display {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 2px solid #e9ecef;
        }

        .sequence-item {
            display: inline-block;
            padding: 5px 10px;
            margin: 2px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
        }

        .sequence-item.current {
            background: #fff3cd;
            border-color: #ffeaa7;
            font-weight: bold;
        }

        .sequence-item.completed {
            background: #d4edda;
            border-color: #c3e6cb;
        }

        @media (max-width: 768px) {
            .simulation-area {
                grid-template-columns: 1fr;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Cache Simulation System</h1>
            <p>4-Way Block Set Associative + MRU Replacement Policy</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <h3>Cache Configuration</h3>
                <div class="form-group">
                    <label for="cacheBlocks">Cache Blocks (Power of 2, Min: 4):</label>
                    <input type="number" id="cacheBlocks" value="8" min="4" max="64" step="4">
                </div>
                <div class="form-group">
                    <label for="lineSize">Line Size (Words, Power of 2, Min: 2):</label>
                    <input type="number" id="lineSize" value="4" min="2" max="16" step="2">
                </div>
                <button class="btn" onclick="initializeCache()">Initialize Cache</button>
            </div>

            <div class="control-group">
                <h3>Test Cases</h3>
                <div class="form-group">
                    <label for="testCase">Select Test Case:</label>
                    <select id="testCase" onchange="onTestCaseChange()">
                        <option value="sequential">Sequential Sequence</option>
                        <option value="mid-repeat">Mid-Repeat Blocks</option>
                        <option value="random">Random Sequence</option>
                        <option value="custom">Custom Sequence</option>
                    </select>
                </div>
                <div class="form-group" id="customInputGroup" style="display: none;">
                    <label for="customInput">Custom Sequence (comma-separated):</label>
                    <textarea id="customInput" placeholder="0, 1, 2, 3, 4, 5, 6, 7"></textarea>
                </div>
                <button class="btn btn-success" onclick="loadTestCase()">Load Test Case</button>
            </div>
        </div>

        <div class="current-step" id="currentStep">
            No simulation loaded
        </div>

        <div class="sequence-display" id="sequenceDisplay">
            <strong>Sequence:</strong> Load a test case to see the sequence
        </div>

        <div class="step-controls">
            <button class="btn btn-secondary" id="prevBtn" onclick="prevStep()" disabled>Previous Step</button>
            <button class="btn" id="nextBtn" onclick="nextStep()" disabled>Next Step</button>
            <button class="btn btn-warning" id="runAllBtn" onclick="runAll()" disabled>Run All</button>
            <button class="btn btn-secondary" onclick="resetSimulation()">Reset</button>
        </div>

        <div class="simulation-area">
            <div class="cache-display">
                <h3>Cache Memory Snapshot</h3>
                <div id="cacheTable">
                    <p>Initialize cache to see memory snapshot</p>
                </div>
            </div>

            <div class="stats-panel">
                <h3>Simulation Statistics</h3>
                <div class="stats-grid" id="statsGrid">
                    <div class="stat-item">
                        <div class="stat-value" id="totalAccesses">0</div>
                        <div class="stat-label">Total Accesses</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="cacheHits">0</div>
                        <div class="stat-label">Cache Hits</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="cacheMisses">0</div>
                        <div class="stat-label">Cache Misses</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="hitRate">0.00%</div>
                        <div class="stat-label">Hit Rate</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="missRate">0.00%</div>
                        <div class="stat-label">Miss Rate</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="avgAccessTime">0.00ns</div>
                        <div class="stat-label">Avg Memory Access Time</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="log-panel">
            <h3>Cache Memory Trace Log</h3>
            <div class="log-content" id="logContent">
                System ready. Initialize cache and load a test case to begin simulation.
            </div>
        </div>
    </div>

    <script>
        // Include the backend classes
        /*
        Cache class implementation
        */
        class Cache {
            constructor(numBlocks, ways, lineSize = 1) {
                this.numBlocks = numBlocks;
                this.ways = ways;
                this.lineSize = lineSize;
                this.cache = this.initCache();
            }

            initCache() {
                const sets = this.numBlocks / this.ways;
                return Array.from({ length: sets }, () => []);
            }

            findBlock(block) {
                const setIndex = block % this.cache.length;
                const set = this.cache[setIndex];
                const wayIndex = set.findIndex(entry => entry === block);
                
                return {
                    found: wayIndex !== -1,
                    setIndex: setIndex,
                    wayIndex: wayIndex
                };
            }

            addBlock(block, setIndex) {
                const set = this.cache[setIndex];
                if (set.length < this.ways) {
                    set.push(block);
                    return true;
                }
                return false;
            }

            removeBlock(block, setIndex) {
                const set = this.cache[setIndex];
                const blockIndex = set.indexOf(block);
                if (blockIndex !== -1) {
                    set.splice(blockIndex, 1);
                    return true;
                }
                return false;
            }

            replaceBlock(oldBlock, newBlock, setIndex) {
                const set = this.cache[setIndex];
                const oldIndex = set.indexOf(oldBlock);
                if (oldIndex !== -1) {
                    set.splice(oldIndex, 1);
                }
                set.push(newBlock);
            }

            getSet(setIndex) {
                return this.cache[setIndex];
            }

            isSetFull(setIndex) {
                return this.cache[setIndex].length >= this.ways;
            }

            reset() {
                this.cache = this.initCache();
            }

            getCache() {
                const cacheCopy = [];
                for (let i = 0; i < this.cache.length; i++) {
                    cacheCopy[i] = [];
                    for (let j = 0; j < this.cache[i].length; j++) {
                        cacheCopy[i][j] = this.cache[i][j];
                    }
                }
                return cacheCopy;
            }

            getStats() {
                let totalBlocks = 0;
                this.cache.forEach(set => {
                    totalBlocks += set.length;
                });
                
                return {
                    totalBlocks: totalBlocks,
                    sets: this.cache.length,
                    ways: this.ways,
                    lineSize: this.lineSize,
                    utilization: ((totalBlocks / this.numBlocks) * 100).toFixed(2) + '%'
                };
            }
        }

        /*
        MRU class implementation
        */
        class MRU {
            constructor(numSets) {
                this.numSets = numSets; 
                this.mruOrder = this.initMRU();
            }

            initMRU() {
                return Array.from({ length: this.numSets }, () => []);
            }

            updateMRU(block, setIndex) {
                const mruSet = this.mruOrder[setIndex];
                const blockIndex = mruSet.indexOf(block);

                if (blockIndex !== -1) {
                    mruSet.splice(blockIndex, 1);
                }
                
                mruSet.push(block);
            }

            getBlockToEvict(setIndex) {
                const mruSet = this.mruOrder[setIndex];
                if (mruSet.length === 0) {
                    return null;
                }
                return mruSet[mruSet.length - 1];
            }

            removeFromMRU(block, setIndex) {
                const mruSet = this.mruOrder[setIndex];
                const blockIndex = mruSet.indexOf(block);
                if (blockIndex !== -1) {
                    mruSet.splice(blockIndex, 1);
                }
            }

            getMRUOrder(setIndex) {
                return this.mruOrder[setIndex];
            }

            getAllMRUOrders() {
                const mruCopy = [];
                for (let i = 0; i < this.mruOrder.length; i++) {
                    mruCopy[i] = [];
                    for (let j = 0; j < this.mruOrder[i].length; j++) {
                        mruCopy[i][j] = this.mruOrder[i][j];
                    }
                }
                return mruCopy;
            }

            reset() {
                this.mruOrder = this.initMRU();
            }

            generateExplanation(block, setIndex, isHit, removedBlock) {
                const mruSet = this.mruOrder[setIndex];
                let explanation = 'Access block ' + block + ' → Set ' + setIndex + '. ';
                
                if (isHit) {
                    explanation += 'HIT! Block ' + block + ' found in cache. Updated MRU order.';
                } else {
                    if (removedBlock !== null) {
                        explanation += 'MISS! Cache full. Removed MRU block ' + removedBlock + ', loaded block ' + block + '.';
                    } else {
                        explanation += 'MISS! Loaded block ' + block + ' into available cache slot.';
                    }
                }
                explanation += ' Current MRU order: [' + mruSet.join(', ') + ']';
                return explanation;
            }
        }

        /*
        Simulator class implementation
        */
        class Simulator {
            constructor() {
                this.memoryBlocks = 1024;
                this.cache = null;
                this.mru = null;
                this.log = [];
                this.currentSequence = [];
                this.currentStep = -1;
                this.stepHistory = [];
                this.isSteppingMode = false;
                this.cacheAccessTime = 1;
                this.memoryAccessTime = 10;
            }

            initCache(numBlocks, ways, lineSize = 1) {
                this.cache = new Cache(numBlocks, ways, lineSize);
                this.mru = new MRU(numBlocks / ways);
                this.stepHistory = [];
                this.currentStep = -1;
                this.log = [];
            }

            copyArray(arr) {
                if (!Array.isArray(arr)) {
                    return arr;
                }
                const copy = [];
                for (let i = 0; i < arr.length; i++) {
                    if (Array.isArray(arr[i])) {
                        copy[i] = this.copyArray(arr[i]);
                    } else {
                        copy[i] = arr[i];
                    }
                }
                return copy;
            }

            accessCacheStep(block, ways, stepNum) {
                const findResult = this.cache.findBlock(block);
                const setIndex = findResult.setIndex;
                
                let hit = findResult.found;
                let removedBlock = null;

                if (hit) {
                    this.mru.updateMRU(block, setIndex);
                } else {
                    if (!this.cache.isSetFull(setIndex)) {
                        this.cache.addBlock(block, setIndex);
                    } else {
                        removedBlock = this.mru.getBlockToEvict(setIndex);
                        this.cache.removeBlock(removedBlock, setIndex);
                        this.mru.removeFromMRU(removedBlock, setIndex);
                        this.cache.addBlock(block, setIndex);
                    }
                    this.mru.updateMRU(block, setIndex);
                }

                let result = hit ? 'HIT' : 'MISS';
                const step = this.createCacheStep(stepNum, block, setIndex, result, removedBlock);
                this.stepHistory.push(step);

                this.log.push({
                    step: stepNum,
                    block: block,
                    setIndex: setIndex,
                    result: result,
                    removed: removedBlock,
                    explanation: this.mru.generateExplanation(block, setIndex, hit, removedBlock)
                });

                return hit;
            }

            createCacheStep(stepNum, block, setIndex, hitStatus, removedBlock) {
                return {
                    stepNum: stepNum,
                    block: block,
                    setIndex: setIndex,
                    hitStatus: hitStatus,
                    removedBlock: removedBlock,
                    cacheState: this.copyArray(this.cache.getCache()),
                    mruState: this.copyArray(this.mru.getAllMRUOrders())
                };
            }

            loadSequentialTest(numBlocks) {
                this.currentSequence = [];
                for (let i = 0; i < 2 * numBlocks; i++) this.currentSequence.push(i);
                for (let i = 0; i < 2 * numBlocks; i++) this.currentSequence.push(i);
                return this.currentSequence;
            }

            loadMidRepeatTest(numBlocks) {
                this.currentSequence = [];
                for (let i = 0; i < numBlocks; i++) this.currentSequence.push(i);
                for (let i = 1; i < numBlocks; i++) this.currentSequence.push(i);
                for (let i = numBlocks; i < 2 * numBlocks; i++) this.currentSequence.push(i);
                const originalLength = this.currentSequence.length;
                for (let i = 0; i < originalLength; i++) {
                    this.currentSequence.push(this.currentSequence[i]);
                }
                return this.currentSequence;
            }

            loadRandomTest() {
                this.currentSequence = [];
                for (let i = 0; i < 64; i++) {
                    this.currentSequence.push(Math.floor(Math.random() * this.memoryBlocks));
                }
                return this.currentSequence;
            }

            loadCustomTest(inputSequence) {
                this.currentSequence = [];
                
                if (typeof inputSequence === 'string') {
                    const blocks = inputSequence.split(/[,\s]+/).filter(block => block.trim() !== '');
                    
                    for (let block of blocks) {
                        const blockNum = parseInt(block.trim());
                        if (!isNaN(blockNum) && blockNum >= 0 && blockNum < this.memoryBlocks) {
                            this.currentSequence.push(blockNum);
                        }
                    }
                } else if (Array.isArray(inputSequence)) {
                    for (let block of inputSequence) {
                        const blockNum = parseInt(block);
                        if (!isNaN(blockNum) && blockNum >= 0 && blockNum < this.memoryBlocks) {
                            this.currentSequence.push(blockNum);
                        }
                    }
                }
                
                return this.currentSequence;
            }

            loadTestCase(testName, numBlocks, lineSize = 1, customInput = null) {
                numBlocks = numBlocks || 8;
                this.initCache(numBlocks, 4, lineSize);
                
                if (testName === 'Sequential Test' || testName === 'sequential') {
                    this.loadSequentialTest(numBlocks);
                } else if (testName === 'Mid-Repeat Test' || testName === 'mid-repeat') {
                    this.loadMidRepeatTest(numBlocks);
                } else if (testName === 'Random Test' || testName === 'random') {
                    this.loadRandomTest();
                } else if (testName === 'Custom Test' || testName === 'custom') {
                    this.loadCustomTest(customInput || '');
                }
                
                return this.currentSequence;
            }

            startStepping() {
                this.isSteppingMode = true;
                this.currentStep = -1;
            }

            nextStep() {
                if (this.currentStep >= this.currentSequence.length - 1) {
                    return false;
                }

                this.currentStep++;
                const block = this.currentSequence[this.currentStep];
                const hit = this.accessCacheStep(block, 4, this.currentStep + 1);
                
                return true;
            }

            prevStep() {
                if (this.currentStep <= 0) return false;
                
                this.currentStep--;
                
                if (this.currentStep >= 0) {
                    const stepData = this.stepHistory[this.currentStep];
                    this.cache.cache = this.copyArray(stepData.cacheState);
                    this.mru.mruOrder = this.copyArray(stepData.mruState);
                    
                    this.stepHistory = this.stepHistory.slice(0, this.currentStep + 1);
                    this.log = this.log.slice(0, this.currentStep + 1);
                } else {
                    this.cache.reset();
                    this.mru.reset();
                    this.stepHistory = [];
                    this.log = [];
                }
                
                return true;
            }

            runAll() {
                while (this.currentStep < this.currentSequence.length - 1) {
                    this.nextStep();
                }
            }

            reset() {
                if (this.cache) this.cache.reset();
                if (this.mru) this.mru.reset();
                this.currentStep = -1;
                this.stepHistory = [];
                this.log = [];
                this.isSteppingMode = false;
            }

            getStats() {
                const totalAccesses = Math.max(this.currentStep + 1, 0);
                const hits = this.log.filter(entry => entry.result === 'HIT').length;
                const misses = this.log.filter(entry => entry.result === 'MISS').length;

                let progress = '0 / 0';
                if (this.currentSequence.length > 0) {
                    progress = `${totalAccesses} / ${this.currentSequence.length}`;
                }

                let lineSize = 1;
                if (this.cache && this.cache.lineSize != null) {
                    lineSize = this.cache.lineSize;
                }

                const totalMemoryAccessTime =
                    hits * lineSize * this.cacheAccessTime +
                    misses * (this.cacheAccessTime + lineSize * this.cacheAccessTime + lineSize * this.memoryAccessTime);

                let averageMemoryAccessTime = 0;
                if (totalAccesses > 0) {
                    averageMemoryAccessTime =
                        (hits / totalAccesses) * this.cacheAccessTime +
                        (misses / totalAccesses) * (this.cacheAccessTime + lineSize * this.memoryAccessTime + this.cacheAccessTime);
                }

                let hitRate = "0.00";
                let missRate = "0.00";

                if (totalAccesses > 0) {
                    hitRate = ((hits / totalAccesses) * 100).toFixed(2);
                    missRate = ((misses / totalAccesses) * 100).toFixed(2);
                }

                return {
                    totalAccesses: totalAccesses,
                    hits: hits,
                    misses: misses,
                    hitRate: hitRate,
                    missRate: missRate,
                    averageMemoryAccessTime: averageMemoryAccessTime.toFixed(2),
                    totalMemoryAccessTime: totalMemoryAccessTime.toFixed(2),
                    progress: progress
                };
            }

            getState() {
                let cache = [];
                let mruOrder = [];

                if (this.cache) {
                    cache = this.cache.getCache();
                }

                if (this.mru) {
                    mruOrder = this.mru.getAllMRUOrders();
                }

                return {
                    cache: cache,
                    mruOrder: mruOrder,
                    currentStep: this.currentStep,
                    sequence: this.currentSequence,
                    log: this.log,
                    stats: this.getStats()
                };
            }

            isComplete() {
                return this.currentStep >= this.currentSequence.length - 1;
            }
        }

        // Global simulator instance
        let simulator = new Simulator();

        // UI Functions
        function initializeCache() {
            const cacheBlocks = parseInt(document.getElementById('cacheBlocks').value);
            const lineSize = parseInt(document.getElementById('lineSize').value);
            
            // Validate power of 2
            if (!isPowerOfTwo(cacheBlocks) || cacheBlocks < 4) {
                alert('Cache blocks must be a power of 2 and at least 4');
                return;
            }
            
            if (!isPowerOfTwo(lineSize) || lineSize < 2) {
                alert('Line size must be a power of 2 and at least 2');
                return;
            }
            
            simulator.initCache(cacheBlocks, 4, lineSize);
            updateCacheDisplay();
            updateStats();
            addLogMessage(`Cache initialized: ${cacheBlocks} blocks, 4-way associative, ${lineSize} words per line`);
        }

        function isPowerOfTwo(n) {
            return n > 0 && (n & (n - 1)) === 0;
        }

        function onTestCaseChange() {
            const testCase = document.getElementById('testCase').value;
            const customInputGroup = document.getElementById('customInputGroup');
            
            if (testCase === 'custom') {
                customInputGroup.style.display = 'block';
            } else {
                customInputGroup.style.display = 'none';
            }
        }

        function loadTestCase() {
            if (!simulator.cache) {
                alert('Please initialize cache first');
                return;
            }
            
            const testCase = document.getElementById('testCase').value;
            const cacheBlocks = parseInt(document.getElementById('cacheBlocks').value);
            const lineSize = parseInt(document.getElementById('lineSize').value);
            let customInput = '';
            
            if (testCase === 'custom') {
                customInput = document.getElementById('customInput').value;
                if (!customInput.trim()) {
                    alert('Please enter a custom sequence');
                    return;
                }
            }
            
            simulator.loadTestCase(testCase, cacheBlocks, lineSize, customInput);
            simulator.startStepping();
            
            updateSequenceDisplay();
            updateStepControls();
            updateCurrentStep();
            updateCacheDisplay();
            updateStats();
            
            addLogMessage(`Test case loaded: ${testCase}`);
            addLogMessage(`Sequence: [${simulator.currentSequence.join(', ')}]`);
            addLogMessage('Ready to begin simulation. Use step controls to proceed.');
        }

        function nextStep() {
            if (!simulator.currentSequence.length) {
                alert('Please load a test case first');
                return;
            }
            
            const hasNext = simulator.nextStep();
            if (hasNext) {
                updateCacheDisplay();
                updateStats();
                updateCurrentStep();
                updateSequenceDisplay();
                updateStepControls();
                
                // Add current step to log
                const currentLog = simulator.log[simulator.log.length - 1];
                if (currentLog) {
                    addLogMessage(`Step ${currentLog.step}: ${currentLog.explanation}`);
                }
            }
        }

        function prevStep() {
            const hasPrev = simulator.prevStep();
            if (hasPrev) {
                updateCacheDisplay();
                updateStats();
                updateCurrentStep();
                updateSequenceDisplay();
                updateStepControls();
                
                if (simulator.currentStep >= 0) {
                    addLogMessage(`Stepped back to step ${simulator.currentStep + 1}`);
                } else {
                    addLogMessage('Returned to initial state');
                }
            }
        }

        function runAll() {
            if (!simulator.currentSequence.length) {
                alert('Please load a test case first');
                return;
            }
            
            addLogMessage('Running all remaining steps...');
            simulator.runAll();
            
            updateCacheDisplay();
            updateStats();
            updateCurrentStep();
            updateSequenceDisplay();
            updateStepControls();
            
            addLogMessage('Simulation completed!');
            
            // Show final statistics
            const stats = simulator.getStats();
            addLogMessage(`Final Results: ${stats.hits} hits, ${stats.misses} misses, ${stats.hitRate}% hit rate`);
        }

        function resetSimulation() {
            simulator.reset();
            updateCacheDisplay();
            updateStats();
            updateCurrentStep();
            updateSequenceDisplay();
            updateStepControls();
            
            // Clear log
            document.getElementById('logContent').innerHTML = 'Simulation reset. Load a test case to begin.';
        }

        function updateCacheDisplay() {
            const cacheTable = document.getElementById('cacheTable');
            
            if (!simulator.cache) {
                cacheTable.innerHTML = '<p>Initialize cache to see memory snapshot</p>';
                return;
            }
            
            const cache = simulator.cache.getCache();
            const mruOrders = simulator.mru ? simulator.mru.getAllMRUOrders() : [];
            
            let html = '<table class="cache-table">';
            html += '<thead><tr><th>Set</th><th>Way 0</th><th>Way 1</th><th>Way 2</th><th>Way 3</th><th>MRU Order</th></tr></thead>';
            html += '<tbody>';
            
            for (let setIndex = 0; setIndex < cache.length; setIndex++) {
                html += `<tr><td><strong>Set ${setIndex}</strong></td>`;
                
                // Display blocks in each way
                for (let way = 0; way < 4; way++) {
                    html += '<td>';
                    if (cache[setIndex][way] !== undefined) {
                        html += `<div class="cache-block">${cache[setIndex][way]}</div>`;
                    }
                    html += '</td>';
                }
                
                // Display MRU order
                html += '<td>';
                if (mruOrders[setIndex] && mruOrders[setIndex].length > 0) {
                    html += `<div class="mru-order">LRU ← [${mruOrders[setIndex].join(', ')}] → MRU</div>`;
                }
                html += '</td>';
                
                html += '</tr>';
            }
            
            html += '</tbody></table>';
            cacheTable.innerHTML = html;
        }

        function updateStats() {
            const stats = simulator.getStats();
            
            document.getElementById('totalAccesses').textContent = stats.totalAccesses;
            document.getElementById('cacheHits').textContent = stats.hits;
            document.getElementById('cacheMisses').textContent = stats.misses;
            document.getElementById('hitRate').textContent = stats.hitRate + '%';
            document.getElementById('missRate').textContent = stats.missRate + '%';
            document.getElementById('avgAccessTime').textContent = stats.averageMemoryAccessTime + 'ns';
        }

        function updateCurrentStep() {
            const currentStepDiv = document.getElementById('currentStep');
            
            if (!simulator.currentSequence.length) {
                currentStepDiv.textContent = 'No simulation loaded';
                return;
            }
            
            const stats = simulator.getStats();
            if (simulator.currentStep >= 0) {
                const currentBlock = simulator.currentSequence[simulator.currentStep];
                const currentLog = simulator.log[simulator.log.length - 1];
                const result = currentLog ? currentLog.result : '';
                
                currentStepDiv.innerHTML = `Step ${simulator.currentStep + 1}: Accessing block ${currentBlock} → <strong>${result}</strong> | Progress: ${stats.progress}`;
            } else {
                currentStepDiv.innerHTML = `Ready to start | Progress: ${stats.progress}`;
            }
        }

        function updateSequenceDisplay() {
            const sequenceDisplay = document.getElementById('sequenceDisplay');
            
            if (!simulator.currentSequence.length) {
                sequenceDisplay.innerHTML = '<strong>Sequence:</strong> Load a test case to see the sequence';
                return;
            }
            
            let html = '<strong>Sequence:</strong> ';
            
            // Show only first 20 items to avoid cluttering
            const displaySequence = simulator.currentSequence.slice(0, 20);
            const hasMore = simulator.currentSequence.length > 20;
            
            for (let i = 0; i < displaySequence.length; i++) {
                const block = displaySequence[i];
                let className = 'sequence-item';
                
                if (i === simulator.currentStep) {
                    className += ' current';
                } else if (i < simulator.currentStep) {
                    className += ' completed';
                }
                
                html += `<span class="${className}">${block}</span>`;
            }
            
            if (hasMore) {
                html += '<span class="sequence-item">...</span>';
                html += `<span style="margin-left: 10px; color: #666;">(${simulator.currentSequence.length} total blocks)</span>`;
            }
            
            sequenceDisplay.innerHTML = html;
        }

        function updateStepControls() {
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const runAllBtn = document.getElementById('runAllBtn');
            
            const hasSequence = simulator.currentSequence.length > 0;
            const canGoPrev = simulator.currentStep > -1;
            const canGoNext = simulator.currentStep < simulator.currentSequence.length - 1;
            
            prevBtn.disabled = !canGoPrev;
            nextBtn.disabled = !canGoNext || !hasSequence;
            runAllBtn.disabled = !canGoNext || !hasSequence;
        }

        function addLogMessage(message) {
            const logContent = document.getElementById('logContent');
            const timestamp = new Date().toLocaleTimeString();
            logContent.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            logContent.scrollTop = logContent.scrollHeight;
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            addLogMessage('Cache Simulation System initialized');
            addLogMessage('Configure cache parameters and load a test case to begin');
            updateStepControls();
        });
    </script>
</body>
</html>